### 10816_숫자카드2
* 시간초과 해결방법
    * 인풋은 사용자 입력을 받고, 문자열로 변환, 추가 스트립 진행과정을 거치게 됨
    * 인풋은 한편 사용자로부터 입력을 받기 전 대기를 위한 프롬프트를 가지고 있음, 때문에 많은 여러줄을 입력을 받는 경우, 한줄 입력을 받기 > 단계 수행 > 대기를 반복하게 됨
    * 해결방법 : sys.stdin.readline()을 사용!! 
        * import sys를 맨 윗줄에 작성후 인풋에 위 구문을 작성
        * sys로 인풋파일을 입력 받는 경우 + readline으로 인풋 값에 입력하는 경우는 답안 제출 시 import sys입력해야함
        * 다만, vscode에는 import sys를 한번만 입력해도 됨

* 파이썬은 1초에 1억번까지 연산 가능
* for 문은 50만번이고 카운트할 때 50만번이므로, 곱해서 2500억번
    * 입력을 50만번 받고, 체크를 50만번 할 때, 입력 받은 한개 당 50만개를 다 세야되니깐 곱하기
    * 딕셔너리는 그냥 가져와, 하면 입력 된 주소값이 있어서 바로 가져올 수 있으니 입력할 때 50만번 + 체크할 때 50만번


* 카운트는 리스트에서 값을 하나씩 빼서 보는 것
* 딕셔너리는 리스트에서 값을 찾는다는 것
* for문에서 이중 함수 사용 시, 이중 for문과 다를 것이 없어 O(N^2)
    * o(n) * 0(n)
    * 딕셔너리 사용 시, 0(n)*0(1)
* for문 , count가 = 각각 0(n), 0(n)인 것 => n제곱
    * n제곱은 파이썬에서 1초에 1만임, 그렇기 때문에 통과 못함!
    
* for문 , 딕셔너리 = 각각 0(n), 0(1)이구요! => 엔
    * 파이썬은 1초당 1억번 계산(0(n)기준, 50만번인 문제에서는 무난히 통과
그렇기 때문에 각 시간 복잡도를 곱한 값이 for, count가 더 높기 때문에라고 이해 곱해서 계산

* 시간 초과가 뜨는 이유는 리스트에서 in키워드로 탐색을 하면 0(n)의 시간이 걸리기 때문
    * 0(n)인 이유는 리스트에서 탐색을 하기 위해 리스트의 모든 값을 다 확인해봐야 되기 때문

* 좋은 알고리즘이란, 인풋을 넣은 후 아웃풋이 나오는 시간이 짧은 알고리즘! 

### counter모듈
* 리스트 안에 있는 숫자들에 대한 빈도수를 딕셔너리 형태로 만듬
